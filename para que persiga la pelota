#include <Arduino.h>
#include <zirconLib.h>

// Configuración de motores
int potencia = 90;

// Configuración UART
#define RX_PIN 0
#define TX_PIN 1
const long BAUD_RATE = 19200;

// Variables para almacenar los datos decodificados
float decodedX = 0.0;
float decodedY = 0.0;
float decodedAngle = 0.0;
int decodedSense = 0;

// Tolerancias de movimiento
const int tolerancia_centrado = 5;    // Grados
const float tolerancia_cercania = 25; // Centímetros

// Estados para la máquina de estados del decodificador
enum DecoderState {
  WAITING_FOR_HEADER,
  READING_BYTE_X,
  READING_BYTE_Y,
  READING_BYTE_ANGLE,
  READING_SENTIDO
};

DecoderState currentState = WAITING_FOR_HEADER;

// Estados para el seguimiento de la pelota
enum TrackingState {
  BUSCANDO,
  GIRANDO,
  AVANZANDO,
};

TrackingState trackingState = BUSCANDO;

// Función para mover el robot en una dirección específica
float mover(float centimetros, int eje) {
  float tiempo = abs(((0.0654 * centimetros) - 0.1785) * 1000);
  
  if (centimetros >= 0) {
    switch (eje) {
      case 3: // Izquierda
        motor1(100, 0);
        motor2(100, 1);
        break;
      case 1: // Adelante
        motor3(100, 0);
        motor2(100, 1);
        break;
      case 2: // Derecha
        motor3(100, 0);
        motor1(100, 1);
        break;
    }
  } else {
    switch (eje) {
      case 3: // Derecha (contrario)
        motor1(100, 1);
        motor2(100, 0);
        break;
      case 1: // Atrás
        motor3(100, 1);
        motor2(100, 0);
        break;
      case 2: // Izquierda (contrario)
        motor3(100, 1);
        motor1(100, 0);
        break;
    }
  }
  
  delay(tiempo);
  
  // Detener motores
  motor1(0, 0);
  motor2(0, 0);
  motor3(0, 0);
  
  return tiempo;
}

// Función para girar el robot
float girar(float angulo) {
  float tiempo = abs(angulo * 43 / 200);

  if (angulo > 0) { 
    motor1(potencia, 0);
    motor2(potencia, 0);
    motor3(potencia, 0);
  } else {
    motor1(potencia, 1);
    motor2(potencia, 1);
    motor3(potencia, 1);
  }
  
  delay(tiempo);
  
  // Detener motores
  motor1(0, 0);
  motor2(0, 0);
  motor3(0, 0);
  
  return tiempo;
}

// Función para detener todos los motores
void detenerMotores() 
{
  motor1(0, 0);
  motor2(0, 0);
  motor3(0, 0);
}

void setup() 
{
  InitializeZircon();
  
  Serial.begin(BAUD_RATE);
  while (!Serial && millis() < 5000);
  Serial.println("Decodificador Teensy iniciado.");

  Serial1.begin(BAUD_RATE);
  Serial.println("Serial1 (UART) iniciado."); 
}

void loop() 
{
  // LEER DATOS DE LA CAMARA Y DECODIFICAR
  if (Serial1.available()) {
    int incomingByte = Serial1.read();
    
    switch (currentState) {
      case WAITING_FOR_HEADER:
        if (incomingByte == 201) {
          currentState = READING_BYTE_X;
        } else if (incomingByte == 202) {
          currentState = READING_BYTE_Y;
        } else if (incomingByte == 203) {
          currentState = READING_BYTE_ANGLE;
        } else if (incomingByte == 204) {
          currentState = READING_SENTIDO;
        }
        break;

      case READING_BYTE_X:
        decodedX = (float)incomingByte / 2.0;
        Serial.print("X: "); Serial.println(decodedX, 2);
        currentState = WAITING_FOR_HEADER;
        break;

      case READING_BYTE_Y:
        decodedY = ((float)incomingByte / 2.0) - 50.0;
        Serial.print("Y: "); Serial.println(decodedY, 2);
        currentState = WAITING_FOR_HEADER;
        break;

      case READING_BYTE_ANGLE:
        decodedAngle = (float)incomingByte - 100.0;
        Serial.print("Angulo: "); Serial.println(decodedAngle, 2);
        currentState = WAITING_FOR_HEADER;
        break;

      case READING_SENTIDO:
        decodedSense = incomingByte;
        Serial.print("Sentido: "); Serial.println(decodedSense);
        Serial.println("--- Paquete completo decodificado ---"); // Indicador de paquete completo
        currentState = WAITING_FOR_HEADER;
        break;
    }
  }

  // LOGICA DEL SEGUIMIENTO DE LA PELOTA 
  switch (trackingState) {
    case BUSCANDO:
      Serial.println("Buscando pelota...");
      if (decodedX > 0) {
        trackingState = GIRANDO; 
      }
      else {
        motor1(potencia, 0);    // Gira hasta que mire la pelota 
        motor2(potencia, 0);
        motor3(potencia, 0);
      }
      break;
      
    case GIRANDO:
      Serial.println("Girando hacia pelota...");
      girar(decodedAngle);
      
      if (abs(decodedAngle) < tolerancia_centrado) {
        trackingState = AVANZANDO;
      }
      break;
      
    case AVANZANDO:
      Serial.println("Avanzando hacia pelota...");
      // Comprobar si esta lo suficientemente cerca
      if (decodedX > tolerancia_cercania) 
      {
        // Si no esta centrado, corrige el giro
        if (abs(decodedAngle) > tolerancia_centrado) {
          girar(decodedAngle); // Gira para corregir el ángulo
        } 
        // Si esta centrado, avanza
        else {
          motor3(100, 0); // Avanzar en eje frontal
          motor2(100, 1); 
        }
      }
      else 
      {
       // Si ya estamos lo suficientemente cerca, detenemos los motores y cambiamos de estado
       detenerMotores();
       trackingState = GIRANDO;
      }
      break;
  }
  
  delay(10); // Pequeña pausa para evitar sobrecarga segun gemini 
}
