#include <Arduino.h>
#include <zirconLib.h>

const long BAUD_RATE = 19200;
int potencia = 90;

// Variables decodificadas
float decodedX = 0.0;
float decodedY = 0.0;
float decodedAngle = 0.0;
int decodedSense = 0;

// Tolerancias (ajusta según precisión deseada)
const float tolerancia_centrado = 6.0;   // grados
const float tolerancia_cercania = 23.0;  // cm

// Estados del seguimiento
enum TrackingState { BUSCANDO, GIRANDO, AVANZANDO };
TrackingState trackingState = BUSCANDO;

// Giro no bloqueante
bool girando = false;
unsigned long tiempoInicioGiro = 0;
unsigned long duracionGiro = 0;
int direccionGiro = 0;

void girar(float angulo) {
  if (girando) return;  // Ya está girando, no reiniciar
  duracionGiro = abs(angulo * 43 / 200);
  tiempoInicioGiro = millis();
  girando = true;
  direccionGiro = (angulo > 0) ? 0 : 1;

  motor1(potencia, direccionGiro);
  motor2(potencia, direccionGiro);
  motor3(potencia, direccionGiro);
}

void detenerMotores() 
{
  motor1(0, 0); motor1(0, 1);
  motor2(0, 0); motor2(0, 1);
  motor3(0, 0); motor3(0, 1);
  girando = false;
}

void setup() 
{
  InitializeZircon();
  Serial.begin(BAUD_RATE);
  while (!Serial && millis() < 5000);
  Serial1.begin(BAUD_RATE);
  Serial.println("Decodificador Teensy iniciado.");
}

void loop() 
{
  // Finalizar giro si ya pasó el tiempo
  if (girando && millis() - tiempoInicioGiro >= duracionGiro) 
  {
    detenerMotores();
    girando = false;

    // Si el estado actual era GIRANDO, pasa a AVANZANDO
    if (trackingState == GIRANDO && abs(decodedAngle) < tolerancia_centrado) 
    {
      trackingState = AVANZANDO;
    }
    return;
  }

  // Leer paquete de OpenMV si no está girando
  if (!girando && Serial1.available() >= 8) 
  {
    int header1 = Serial1.read();
    int x = Serial1.read();
    int header2 = Serial1.read();
    int y = Serial1.read();
    int header3 = Serial1.read();
    int ang = Serial1.read();
    int header4 = Serial1.read();
    int sentido = Serial1.read();

    if (header1 == 201 && header2 == 202 && header3 == 203 && header4 == 204) 
    {
      decodedX = x / 2.0;
      decodedY = (y / 2.0) - 50.0;
      decodedAngle = ang - 100.0;
      decodedSense = sentido;

      // Mostrar datos
      Serial.print("X: "); Serial.print(decodedX);
      Serial.print(" | Y: "); Serial.print(decodedY);
      Serial.print(" | Ang: "); Serial.print(decodedAngle);
      Serial.print(" | Sentido: "); Serial.println(decodedSense);

      // Lógica de seguimiento
      switch (trackingState) 
      {
        case BUSCANDO:
          Serial.println("Buscando pelota...");
          
          if (decodedX > 0) 
          {
            trackingState = GIRANDO;
          }
          else 
          {
            // Gira buscando pelota
            motor1(potencia, 0);
            motor2(potencia, 0);
            motor3(potencia, 0);
          }
          break;

        case GIRANDO:
          Serial.println("Girando hacia pelota...");
          if (abs(decodedAngle) >= tolerancia_centrado) 
          {
            girar(decodedAngle);
          } 
          else 
          {
            trackingState = AVANZANDO;
          }
          break;

        case AVANZANDO:
          Serial.println("Avanzando hacia pelota...");
          if (decodedX > tolerancia_cercania) 
          {
            if (abs(decodedAngle) > tolerancia_centrado) 
            {
              trackingState = GIRANDO;  // Reajustar ángulo
            } 
            else 
            {
              // Avanzar al frente
              motor3(100, 0);
              motor2(100, 1);
            }
          } 
          else 
          {
            Serial.println("Pelota alcanzada.");
            detenerMotores();
            //trackingState = BUSCANDO;
          }
          break;
      }

    } 
    else 
    {
      Serial.println("Paquete inválido, descartado.");
    }
  }
}
