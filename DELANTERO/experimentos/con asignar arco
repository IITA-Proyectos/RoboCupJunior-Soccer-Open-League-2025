#include <Arduino.h>
#include <zirconLib.h>
//#include <Wire.h> 
//#include <Adafruit_Sensor.h> 
//#include <Adafruit_BNO055.h>

// Pines motores
#define INA1 2
#define INB1 5
#define PWM1 3

#define INA2 8
#define INB2 7
#define PWM2 6

#define INA3 11
#define INB3 12
#define PWM3 4

// Pruebas 
bool prueba_hay = false;
bool prueba_coordenadas = false; 
bool prueba_sensores = false; 

// giroscopo
//Adafruit_BNO055 bno = Adafruit_BNO055(55, 0x28);
float correccion;
float error = 0;
float initialYaw = 0;
float currentYaw;
float kp = 0.3;

// variables lineas
int blanco = 710;

// Comunicación serial
#define START_BYTE 0xAA;
const long BAUD_RATE = 19200;

// Variables velocidades
float k;
float g = 0.3; 
float a = 0.4; 

// Variables ángulos
float anguloPelota = 0.0;
float anguloArco_Amarillo = 0.0; 
float anguloArco_Azul = 0.0;

// Posiciones codificadas
int codedYp = 0, codedYam = 0, codedYaz = 0;
int codedXp = 0, codedXam = 0, codedXaz = 0;

// Posiciones decodificadas
float Xp = 0.0, Yp = 0.0;
float Xam = 0.0, Yam = 0.0;
float Xaz = 0.0, Yaz = 0.0;

// Headers 
int header1 = 0; 
int header2 = 0; 
int header3 = 0; 

// Presencia de objetos
bool haypelota = false;
bool hayarco_amarillo = false;
bool hayarco_azul = false; 

// Asignar arcos 
bool hayarco_rival = false; 
bool hayarco_nuestro = false; 

float X_nuestro, Y_nuestro, anguloArco_nuestro; 
float X_rival, Y_rival, anguloArco_rival; 

// Tolerancias
const float tolerancia_centrado = 20.0;
const float tolerancia_cercania = 50.0;
const float tolerancia_apuntado = 15.0; 

// Máquina de estados
enum Estado { 
ASIGNAR_ARCOS_parar, ASIGNAR_ARCOS_giro, ASIGNAR_ARCOS, 
IMPULSO_INICIAL_GIRANDO, GIRANDO, 
APUNTAR_PELOTA, AVANZANDO, CENTRANDO,
PATEANDO_adelante, PATEANDO_atras, PATEANDO_pausa,
AVANZANDO_POR_TIEMPO,
DETECTA_LINEA_1, DETECTA_LINEA_2, DETECTA_LINEA_3 
};
Estado estado = ASIGNAR_ARCOS_giro;

unsigned long millis_inicio_estado = millis();
unsigned long millis_pelota = millis();

// ---- FUNCIONES DE MOVIMIENTO ----

void girar() {
  analogWrite(PWM1, 100 * g); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
  analogWrite(PWM2, 100 * g); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
  analogWrite(PWM3, 100 * g); digitalWrite(INA3, 0); digitalWrite(INB3, 1);
}

void parar() {
  analogWrite(PWM1, 0); digitalWrite(INA1, 0); digitalWrite(INB1, 0);
  analogWrite(PWM2, 0); digitalWrite(INA2, 0); digitalWrite(INB2, 0);
  analogWrite(PWM3, 0); digitalWrite(INA3, 0); digitalWrite(INB3, 0);
}
void avanzar() {
  analogWrite(PWM1, 100); digitalWrite(INA1, 1); digitalWrite(INB1, 0);
  analogWrite(PWM2, 100); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
  analogWrite(PWM3, 0);   digitalWrite(INA3, 0); digitalWrite(INB3, 1);
}
// RETROCEDER
void retroceder1() {
  analogWrite(PWM1, 0); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
  analogWrite(PWM2, 100); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
  analogWrite(PWM3, 100);   digitalWrite(INA3, 1); digitalWrite(INB3, 0);
}
void retroceder2() {
  analogWrite(PWM1, 100); digitalWrite(INA1, 1); digitalWrite(INB1, 0);
  analogWrite(PWM2, 0); digitalWrite(INA2, 1); digitalWrite(INB2, 0);
  analogWrite(PWM3, 100);   digitalWrite(INA3, 0); digitalWrite(INB3, 1);
}
void retroceder3() {
  analogWrite(PWM1, 100); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
  analogWrite(PWM2, 100); digitalWrite(INA2, 1); digitalWrite(INB2, 0);
  analogWrite(PWM3, 0);   digitalWrite(INA3, 0); digitalWrite(INB3, 1);
}

// PATEAR 
void avanzar_patear() {
  analogWrite(PWM1, 250); digitalWrite(INA1, 1); digitalWrite(INB1, 0);
  analogWrite(PWM2, 250); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
  analogWrite(PWM3, 0);   digitalWrite(INA3, 0); digitalWrite(INB3, 1);
}

void retroceder_patear() {
  analogWrite(PWM1, 150); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
  analogWrite(PWM2, 150); digitalWrite(INA2, 1); digitalWrite(INB2, 0);
  analogWrite(PWM3, 0);   digitalWrite(INA3, 1); digitalWrite(INB3, 0);
}

// ---- SETUP ----
void setup() {
  InitializeZircon();
  Serial.begin(BAUD_RATE);
  Serial1.begin(BAUD_RATE);

  Serial.println("Decodificador iniciado");

  millis_inicio_estado = millis();
  pinMode(LED_BUILTIN,OUTPUT);
}

  //----------GIROSCOPO-------
//  if (!bno.begin()) {
//    Serial.println("¡No se pudo encontrar el BNO055!");
//    while (1);
//  }
//  bno.setExtCrystalUse(true);
//
// sensors_event_t event;
//  bno.getEvent(&event);
//  initialYaw   = event.orientation.x; // 0..360

// ---- LOOP ----
void loop() {
  // GIROSCOPO
//  sensors_event_t event;
//  bno.getEvent(&event);
//  currentYaw   = event.orientation.x;
 digitalWrite(LED_BUILTIN,haypelota);
  // Lectura de datos serial
  if (Serial1.available() >= 9)
  {
    header1 = Serial1.read();
    if (header1 == 201)
    {
      codedXp = Serial1.read();
      codedYp = Serial1.read();
      header2 = Serial1.read(); 
      codedXam = Serial1.read();
      codedYam = Serial1.read();
      header3 = Serial1.read(); 
      codedXaz = Serial1.read();
      codedYaz = Serial1.read(); 

      if (header1 == 201 && header2 == 202 && header3 == 203)
      {
        Xp = codedXp; 
        Yp = codedYp - 100; 
        Xam = codedXam; 
        Yam = codedYam - 100; 
        Xaz = codedXaz; 
        Yaz = codedYaz - 100; 

        // Calcular el ángulos
          anguloPelota = atan2(Yp, Xp) * 180.0 / PI;
          anguloArco_Amarillo = atan2(Yam, Xam) * 180.0 / PI;
          anguloArco_Azul = atan2(Yaz, Xaz) * 180.0 / PI;

  ////      // Mostrar datos
  //      Serial.print("X pelota: "); Serial.print(Xp);
  //      Serial.print(" | Y pelota: "); Serial.print(Yp);
  //      Serial.print(" | X arco amarillo: "); Serial.print(Xam);
  //      Serial.print(" | Y arco amarillo: "); Serial.print(Yam);
  //      Serial.print(" | X arco azul: "); Serial.print(Xaz);
  //      Serial.print(" | Y arco azul: "); Serial.println(Yaz);


        if ( Xp == 0 )
        { haypelota = false; }
        else
        { 
          haypelota = true; 
          millis_pelota = millis(); 
          
        }

        if ( Xam == 0 )
        { hayarco_amarillo = false; }
        else
        { hayarco_amarillo = true; } 

        if ( Xaz == 0 )
        { hayarco_azul = false; }
        else
        { hayarco_azul = true; }
  //
  //      Serial.print("pelota: "); Serial.print(haypelota); 
  //      Serial.print("| arco amarillo: "); Serial.print(hayarco_amarillo);
  //      Serial.print("| arco azul: "); Serial.println(hayarco_azul);
      }
    } 
    else
    {
     hayarco_azul= false;
     hayarco_amarillo=false;
     haypelota=false; 
   }  
  }


  // LECTURA SENSORES DE LINEA 
  int s1 = readLine(1); // Sensor izquierdo
  int s2 = readLine(2); // Sensor centro
  int s3 = readLine(3); // Sensor derecho
  
  if(prueba_sensores)
  {
    Serial.print(" s1: ");
    Serial.print(s1);
    Serial.print(" | s2: ");
    Serial.print(s2);
    Serial.print(" | s3: ");
    Serial.println(s3);
  }

// Máquina de estados
  switch (estado) 
  { 
    case ASIGNAR_ARCOS_giro: 
    // giro 180° despues modificar con giroscopo 
    analogWrite(PWM1, 65 ); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
    analogWrite(PWM2, 65 ); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
    analogWrite(PWM3, 65 ); digitalWrite(INA3, 0); digitalWrite(INB3, 1); 
    if ( millis() - millis_inicio_estado >= 340 )
    { 
      millis_inicio_estado = millis(); 
      estado = ASIGNAR_ARCOS_parar; 
    }
    break; 

    case ASIGNAR_ARCOS_parar: 
      parar(); 
      if ( millis() - millis_inicio_estado >= 1000 )
      {
        millis_inicio_estado = millis(); 
        estado = ASIGNAR_ARCOS; 
      }
    break; 

    case ASIGNAR_ARCOS: 
      if ( hayarco_amarillo && (hayarco_azul == false))
      {
        hayarco_rival = hayarco_azul; 
        Xaz = X_rival; 
        Yaz = Y_rival; 
        anguloArco_Azul = anguloArco_rival;

        hayarco_nuestro = hayarco_amarillo;  
        Xam = X_nuestro;  
        Yam = Y_nuestro; 
        anguloArco_Amarillo = anguloArco_nuestro; 
      }
      if ( hayarco_azul && (hayarco_amarillo == false)) 
      {
        hayarco_rival = hayarco_amarillo;
        Xam = X_rival; 
        Yam = Y_rival; 
        anguloArco_Amarillo = anguloArco_rival;
        
        hayarco_nuestro = hayarco_azul;  
        Xaz = X_nuestro;  
        Yaz = Y_nuestro; 
        anguloArco_Azul = anguloArco_nuestro;  
      }
      if ( (hayarco_rival == hayarco_amarillo) or (hayarco_rival == hayarco_azul) )
      {
        millis_inicio_estado = millis(); 
        estado = IMPULSO_INICIAL_GIRANDO; 
      }    
      else 
      { 
        millis_inicio_estado = millis(); 
      }
    break; 

    case IMPULSO_INICIAL_GIRANDO: 
    // girar pero con más potencia
    analogWrite(PWM1, 80 ); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
    analogWrite(PWM2, 80 ); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
    analogWrite(PWM3, 80 ); digitalWrite(INA3, 0); digitalWrite(INB3, 1); 
    
    if (millis() - millis_inicio_estado >= 50) 
    { 
      millis_inicio_estado = millis(); 
      estado = GIRANDO; 
    } 

    if ( s1 >= blanco )
    { 
      estado = DETECTA_LINEA_1; 
      millis_inicio_estado = millis();
    }
    if ( s2 >= blanco )
    { 
      estado = DETECTA_LINEA_2; 
      millis_inicio_estado = millis();
    }
    if ( s3 >= blanco )
    { 
      estado = DETECTA_LINEA_3; 
      millis_inicio_estado = millis();
    }
    break; 

    case GIRANDO:
      if (haypelota) 
      { 
        parar(); 
        if(millis() - millis_inicio_estado >= 1000) // esperar un sgundo por la inercia 
        {
          estado = APUNTAR_PELOTA;
          millis_inicio_estado = millis(); 
        }
      } 
      else 
      {
        girar();
      }

      if (millis() - millis_inicio_estado >= 5000)
      { 
        millis_inicio_estado = millis(); 
        estado = AVANZANDO_POR_TIEMPO;
      }

      if ( s1 >= blanco )
      { 
        estado = DETECTA_LINEA_1; 
        millis_inicio_estado = millis();
      }
      if ( s2 >= blanco )
      { 
        estado = DETECTA_LINEA_2; 
        millis_inicio_estado = millis();
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }

      break;

    case AVANZANDO_POR_TIEMPO: 
      avanzar(); 

      if (millis() - millis_inicio_estado >= 500)
      { 
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO; 
      }

    // SALIDAS
      if ( haypelota == true ) 
      {
        millis_inicio_estado = millis(); 
        estado = APUNTAR_PELOTA; 
      }

      // salida sensores blanco 
      if ( s1 >= blanco )
      { 
        estado = DETECTA_LINEA_1; 
        millis_inicio_estado = millis();
      }
      if ( s2 >= blanco )
      { 
        estado = DETECTA_LINEA_2; 
        millis_inicio_estado = millis();
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }
    break; 

    case APUNTAR_PELOTA: 
    if (abs(anguloPelota) >= tolerancia_apuntado) 
    {
      if (anguloPelota > 0) 
      { 
        // enciende motores en sentido Anti horario 
        analogWrite(PWM1, 100 * a); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
        analogWrite(PWM2, 100 * a); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
        analogWrite(PWM3, 100 * a); digitalWrite(INA3, 0); digitalWrite(INB3, 1);
      } 
      else 
      { 
        // enciende motores en sentido Horario 
        analogWrite(PWM1, 100 * a); digitalWrite(INA1, 1); digitalWrite(INB1, 0);
        analogWrite(PWM2, 100 * a); digitalWrite(INA2, 1); digitalWrite(INB2, 0);
        analogWrite(PWM3, 100 * a); digitalWrite(INA3, 1); digitalWrite(INB3, 0);
      } 
    }
    else
    {
      millis_inicio_estado = millis(); 
      estado = AVANZANDO; 
    }

    if (millis() - millis_pelota >= 1000)   // si deja de ver la pelota
    {
      millis_inicio_estado = millis(); 
      estado = IMPULSO_INICIAL_GIRANDO;
    } 

    if (millis() - millis_inicio_estado >= 20000)   // timeout 
    {
      millis_inicio_estado = millis();
      estado = IMPULSO_INICIAL_GIRANDO;
    }

    // salida sensores blanco 
    if ( s1 >= blanco )
    { 
      estado = DETECTA_LINEA_1; 
      millis_inicio_estado = millis();
    }
    if ( s2 >= blanco )
    { 
      estado = DETECTA_LINEA_2; 
      millis_inicio_estado = millis();
    }
    if ( s3 >= blanco )
    { 
      estado = DETECTA_LINEA_3; 
      millis_inicio_estado = millis();
    }
    break;


    case AVANZANDO:
      avanzar();
    
    // SALIDAS 
      // si ya esta lo suficientemente cerca de la pelota 
      if (haypelota && Xp <= tolerancia_cercania) 
      {
        millis_inicio_estado = millis();
        estado = CENTRANDO;
      } 

      // si deja de apuntar a la pelota 
      if (abs(anguloPelota) >= tolerancia_apuntado)
      { 
        millis_inicio_estado = millis(); 
        estado = APUNTAR_PELOTA;
      }

      // si deja de ver la pelota
      if (millis() - millis_pelota >= 1000) 
      {
        millis_inicio_estado = millis(); 
        estado = IMPULSO_INICIAL_GIRANDO;
      } 

      // timeout
      if (millis() - millis_inicio_estado >= 20000)
      {
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO;
      }

      if ( s1 >= blanco )
      { 
        estado = DETECTA_LINEA_1; 
        millis_inicio_estado = millis();
      }
      if ( s2 >= blanco )
      { 
        estado = DETECTA_LINEA_2; 
        millis_inicio_estado = millis();
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }
      break;

    case CENTRANDO:
      k = 0.4;
      
        analogWrite(PWM1, 60 * k); digitalWrite(INA1, 0); digitalWrite(INB1, 1);
        analogWrite(PWM2, 60 * k); digitalWrite(INA2, 0); digitalWrite(INB2, 1);
        analogWrite(PWM3, 180 * k); digitalWrite(INA3, 1); digitalWrite(INB3, 0);

    // SALIDAS 
      // cuando apunta al arco   
      if (hayarco_rival && haypelota && (abs(Yp - Y_rival)<= tolerancia_centrado)) 
      {
        millis_inicio_estado = millis();
        estado = PATEANDO_adelante;
      } 
      
      // para que corriga la semi-circunferencia 
      if (abs(anguloPelota) >= tolerancia_apuntado)
      { 
        millis_inicio_estado = millis(); 
        estado = APUNTAR_PELOTA;
      } 

      // si dejo de ver la pelota pero si la tiene cerca 
      if ( millis() - millis_inicio_estado >= 5000 && hayarco_rival)
      {
        millis_inicio_estado = millis(); 
        estado = PATEANDO_adelante;
      }
      
      // si dejo de ver la pelota totalmente 
      if (millis() - millis_pelota >= 5000) 
      {
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO;
      } 
      
      if (millis() - millis_inicio_estado >= 15000)
      {
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO;
      }
      
      if ( s1 >= blanco )
      { 
        millis_inicio_estado = millis();
        estado = DETECTA_LINEA_1; 
      }
      if ( s2 >= blanco )
      { 
        millis_inicio_estado = millis();
        estado = DETECTA_LINEA_2; 
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }

    break;
    
    case PATEANDO_adelante:
      avanzar_patear();
      if (millis() - millis_inicio_estado >= 300) 
      {
        parar();
        millis_inicio_estado = millis();
        estado = PATEANDO_pausa;
      }
      
      if ( s1 >= blanco )
      { 
        estado = DETECTA_LINEA_1; 
        millis_inicio_estado = millis();
      }
      if ( s2 >= blanco )
      { 
        estado = DETECTA_LINEA_2; 
        millis_inicio_estado = millis();
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }
    break;

    case PATEANDO_pausa: 
      parar();
      if (millis() - millis_inicio_estado >= 500) 
      {
        estado = PATEANDO_atras;
        millis_inicio_estado = millis();
      }  
      
      if ( s1 >= blanco )
      { 
        estado = DETECTA_LINEA_1; 
        millis_inicio_estado = millis();
      }
      if ( s2 >= blanco )
      { 
        estado = DETECTA_LINEA_2; 
        millis_inicio_estado = millis();
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }
    break;
      
    case PATEANDO_atras: 
      retroceder_patear();
      if (millis() - millis_inicio_estado >= 400) 
      {
        parar();
        estado = IMPULSO_INICIAL_GIRANDO;
        millis_inicio_estado = millis();
      }
      
      if ( s1 >= blanco )
      { 
        estado = DETECTA_LINEA_1; 
        millis_inicio_estado = millis();
      }
      if ( s2 >= blanco )
      { 
        estado = DETECTA_LINEA_2; 
        millis_inicio_estado = millis();
      }
      if ( s3 >= blanco )
      { 
        estado = DETECTA_LINEA_3; 
        millis_inicio_estado = millis();
      }
    break; 

    case DETECTA_LINEA_1: 
      retroceder1(); 
      if (millis() - millis_inicio_estado >= 400)
      {
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO; 
      }
    break; 

    case DETECTA_LINEA_2: 
      retroceder2(); 
      if (millis() - millis_inicio_estado >= 400)
      {
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO; 
      }
      break; 

    case DETECTA_LINEA_3: 
      retroceder3(); 
      if (millis() - millis_inicio_estado >= 400)
      {
        millis_inicio_estado = millis();
        estado = IMPULSO_INICIAL_GIRANDO; 
      }
      break; 
  }
}
